from random import randrange
from typing import Tuple

import pygame
import pyscroll

from cannonball import CannonBall
from enemy import Enemy
from gamedata import GameData
from gamestate import GameState
from gamestate import GameStateID
from math import atan2, degrees
from player import Player, ShipCondition
from A_star_pathfinding import Pathfinding
import sys
import math



# there seems to be an issues in the navigation where if you get too close to an island it seems to bug out, not too sure why to look in after



class Nodes:

    def __init__(self, Tile):
        self.parent = None  # a reference to the parent whihc will be type node
        self.tile = Tile  # the tile this wil be at

        self.h_score = 0
        self.g_score = 0  # set it
        self.f_score = 0


class GamePlay(GameState):
    """ The game play state is the core of the game itself.

    The role of this class is to process the game logic, update
    the players positioning and render the resultant game-world.
    The logic for deciding on victory or loss should be handled by
    this class and its update function should return GAME_OVER or
    GAME_WON when the end game state is reached.
    """

    def __init__(self, data: GameData) -> None:
        """ Creates the game world

        Use the constructor to initialise the game world in a "clean"
        state ready for the player. This includes resetting of player's
        health and the enemy positions.

        Args:
            data (GameData): The game's shared data
        """

        super().__init__(data)
        self.id = GameStateID.GAMEPLAY
        self.debug = True

        # gameplay Specific Data
        self.player = Player()
        self.group = None
        self.cannonballs = []
        self.enemies = []
        #self.dead = False  # talk with the other script
        #self.won = False
        self.timer = 0

        # helper functions
        self.loadMap()
        self.loadPlayer()

        # A* stuff
        self.desired_path = []


    def input(self, event: pygame.event) -> None:
        """ Handles the player's input

        This function handles all of the player's input in the game.
        At present, it looks to see if a specific mouse button is
        pressed and will act accordingly. For example, to launch a
        cannon you need to use the right click.

        Args:
            event (pygame.Event): The event generated by pygame
        """

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 2:   #middle click
            goal_node = self.gamedata.gamemap.tile(self.gamedata.gamemap.inverse(event.pos))  # get the position of the end goal and turn AI on

            self.player.use_AI = True

            if self.gamedata.gamemap.costs[goal_node[1]][goal_node[0]] >= 100: # check if the end goal (where the player clicked is an island), if it is dont use the AI
                pass
            else:  # else start the class to begin the AI
                start_node = self.gamedata.gamemap.tile(self.player.position)
                self.desired_path = Pathfinding(start_node, goal_node, self.gamedata.gamemap.costs).decided_path # return and save the wanted tile x and y in an array used after
                for i in range(len(self.desired_path)):
                    print(self.desired_path[i].tile)


        # has player right clicked?
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
            to_world = self.gamedata.gamemap.inverse(event.pos)
            cannonball = CannonBall(self.player.rect.center, to_world)
            self.cannonballs.append(cannonball)
            self.group.add(cannonball)



        # has player released left mouse btn?
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.player.mouse_down = False

        # toggle debug mode if d key is pressed
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_d:
            self.debug = not self.debug
            return


        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self.player.mouse_down = True
            self.player.use_AI = False


        if self.player.mouse_down is True:
            to_world = self.gamedata.gamemap.inverse(event.pos)
            self.player.destination = (to_world[0], to_world[1])

            dx = self.player.destination[0] - self.player.position[0]
            dy = self.player.destination[1] - self.player.position[1]
            rad = atan2(dy, dx)
            self.player.rotate(degrees(rad))


        if event.type == pygame.KEYDOWN and event.key == pygame.K_b:
            self.player.health = self.player.health - 1


    def loadMap(self) -> None:
        """ Loads the map and spawns enemies
        """
        self.group = pyscroll.PyscrollGroup(map_layer=self.gamedata.gamemap.map, default_layer=4)

        while len(self.enemies) != 3:
            enemy = Enemy()

            while enemy.rect.collidelist(self.gamedata.gamemap.islands) != -1:
                enemy.rect.x = randrange(0, self.gamedata.gamemap.map.map_rect.w - enemy.rect.width)
                enemy.rect.y = randrange(0, self.gamedata.gamemap.map.map_rect.h - enemy.rect.height)

            self.enemies.append(enemy)
            self.group.add(enemy)

    def loadPlayer(self) -> None:
        """ Loads the player and sets initial position
        """
        self.player.position = (1920, 1230)
        self.player.destination = self.player.position
        self.player.update(0)
        self.group.add(self.player)

    def update(self, dt: float) -> GameStateID:
        """ Updates the game world

        Processes the game world logic. You should handle collisions,
        actions and AI actions here. At present cannon balls are
        updated and so are player collisions with the islands, but
        consider how the ships will react to each other

        Args:
            dt (float): The time between ticks.
        """







        if len(self.desired_path) > 0:   # if the desired path array is not empty there are tiles to go to

            to_world = self.gamedata.gamemap.world(self.desired_path[len(self.desired_path) - 1].tile)
            self.player.destination = (to_world[0], to_world[1])

            if (int(self.player.position[0]) <= self.gamedata.gamemap.world(self.desired_path[len(self.desired_path) - 1].tile)[0] + 4 and int(self.player.position[0]) >= self.gamedata.gamemap.world(self.desired_path[len(self.desired_path) - 1].tile)[0] - 4) and (int(self.player.position[1]) <= self.gamedata.gamemap.world(self.desired_path[len(self.desired_path) - 1].tile)[1] + 4 and int(self.player.position[1]) >= self.gamedata.gamemap.world(self.desired_path[len(self.desired_path) - 1].tile)[1] - 4):
                self.desired_path.pop()  # once the player is in that tile delete it and go to the next untill none left



        if len(self.desired_path) > 0:   # if the desired path array is not empty there are tiles to go to

            for x in self.desired_path:
                print("siuhdhis")














        if self.player.health == 0:
            return GameStateID.GAME_OVER

        if self.player.score == 1100:
            return GameStateID.WINNER_WINNER

        self.resolveCannonballs()

        self.resolvePlayerCollisions(dt)    # called function to check for collision

        self.group.update(dt)


        return GameStateID.GAMEPLAY



    def resolveCannonballs(self) -> None:
        """ Updates the active cannon balls in the world

        Checks to see if the cannon balls have reached their target
        or collided with a ship. If they hit a ship the ship's hp
        will drop by 1. This of course can be changed or tweaked.
        At present if the ship's hp is below 0, the console will
        print the "dead" message
        """
        # check to see if canonballs are finished
        for sprite in self.cannonballs:

            # check for collisions
            for enemy in self.enemies:
                if enemy.rect.colliderect(sprite.rect):
                    self.group.remove(sprite)
                    self.cannonballs.remove(sprite)
                    enemy.hp -= 1
                    print(enemy.hp)
                    self.player.score = self.player.score + 100
                    if enemy.hp == 0:
                        print("dead")
                        self.enemies.remove(enemy)

            if sprite.position == sprite.destination:
                # as lerping reduces distance over time, it might make
                # more sense to check distance between two vectors and
                # remove when close "enough"
                self.group.remove(sprite)
                self.cannonballs.remove(sprite)





    def resolvePlayerCollisions(self, dt) -> None:
        """Checks for collisions with the islands
        """

        if self.player.rect.collidelist(self.gamedata.gamemap.islands) > -1:
            print("Collision")
            self.player.move_back(dt)





    def render(self, screen: pygame.Surface) -> None:
        """ Renders the map, player and score
        """
        # center the map/screen on our Hero
        self.group.center(self.player.rect.center)

        # draw the map and all sprites
        self.group.draw(screen)

        # score
        textsurface = self.gamedata.fonts["scoreboard"].render(f'{self.player.score:06d}', True, (0, 0, 0))
        screen.blit(textsurface, (15, 25))

        # debug rendering
        self.render_debug(screen)

    def render_debug(self, screen: pygame.Surface) -> None:
        """ Renders the debug information if DEBUG is True

        Use this function to display debug information about the game world
        on the screen. At present it will print the ships current location
        in both world space and tile space. You could add extra info to help
        development such as the player's HP or it's current state.

        Args:
            screen (pygame.Surface): The window to render to
        """

        debug_font = self.gamedata.fonts["debug"]
        if self.debug:
            screen.blit(debug_font.render(f'{int(self.player.position[0]), int(self.player.position[1])}',
                                          True, (0, 0, 0)), (15, 80))

            screen.blit(debug_font.render(f'{self.gamedata.gamemap.tile(self.player.position)}',
                                          True, (0, 0, 0)), (15, 105))
